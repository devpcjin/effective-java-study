# 인터페이스의 변화
## 인터페이스 기본 메소드와 스태틱 메소드
### 기본 메소드 (Default Methods)
- 인터페이스에 메소드 선언이 아니라 구현체를 제공하는 방법
    - Foo.java (Interface)
        ```java
        void printName();

        default void printNameUpperCase(){
            System.out.println("FOO");
        }
        ```
    - DefaultFoo.java (Class)
        ``` java
        @Override
        public void printName() {
            System.out.println("DefaultFoo");
        }
        ```
- 해당 인터페이스를 구현한 클래스를 손상시키지 않고 새 기능을 추가할 수 있음
- 기본 메소드는 구현체가 모르게 추가된 기능으로 그만큼 리스크가 있음
    - 구현체에 따라 런타임 에러 발생 가능
    - `@implSpec` 자바 doc 태그를 사용하여 문서화 할것.
- Object에서 제공하는 기능은 기본 메소드로 제공할 수 없음
- 인터페이스 구현체가 재정의 할 수도 있음

### 다이아몬드 문제
- 원인 
    -  인터페이스를 다중 상속할 때 발생
        - `같은 기본메소드`를 가지고 있는 `두 인터페이스`를 상속할 때
- 해결
    - implements한 class에서 `해당 기본 메소드 재정의`


## 자바 8 API의 기본 메소드와 스태틱 메소드
- 예제
```java
List<String> name = new ArrayList<>();

name.add("cheoljin");
name.add("steel");
name.add("good");
name.add("foo");
```
### Iterable의 기본 메소드 (반복 가능한 객체)
- forEach()
    - 한 개씩 출력
    ```java
    name.forEach(System.out::println);
    ```
- spliterator()
    - 반으로 나눔
    ```java
    Spliterator<String> spliterator = name.spliterator();
    Spliterator<String> spliterator1 = spliterator.trySplit();
    while(spliterator.tryAdvance(System.out::println));
    System.out.println("==================");
    while(spliterator1.tryAdvance(System.out::println));
    ```

### Collection의 기본 메소드
- stream() / parallelStream()
- removeIf()
    - 일치하는 조건 제거
    ``` java
    name.removeIf(s -> s.startsWith("c"));

    name.forEach(System.out::println)
    ```
### Comparator의 기본 메소드 및 스태틱 메소드
- reversed()
- thenComparing()
- static reverseOrder() / naturalOrder()
- static nullsFirst() / nullsLast()
- static comparing()
